\chapter{Policy}

Here we are going to introduce three dispatching policies --
\emph{priority-based}, \emph{proportion-based} and
\emph{deadline-based}.
Each of them requires different parameters such as job priority,
execution efficiency per different server and execution deadline.
The decision maker will make dispatching plans to according
to the specified policy.


\section{Priority-based Policy}

The idea behind this policy is to make the job with highest priority
runs as fast as possible.
Intuitively, we can sort the jobs according to their priority then
greedily schedule as many workers as possible to each job in that order.
However, this might cause \emph{starvation} that lower priority jobs
never get executed.
To solve this, we preserve a portion $r \in [0,1]$ of workers for low
priority jobs and job with the highest priority can use only the
unpreserved workers.
The algorithm is shown as algorithm~\ref{algo:priority-based}.

\begin{algorithm}
  \DontPrintSemicolon % Some LaTeX compilers require you to use
  \KwIn{
	workerSet=$\{w_1, w_2, \ldots, w_m\}$,
	jobSet=$\{j_1, j_2, \ldots, j_n\}$,
	preserving rate $r\in[0,1]$
  }
  \KwOut{The largest element in the set}
  result $\gets$ KeyValueMap(key $\to \{\}$ for all key $\in$ $jobSet$)\;
  jobSet $\gets$ $sortByPriority($jobSet$)$\;
  preserved $\gets$ $floor((1-r) * $workerSet.size$)$\;
  c $\gets$ $min($obSet[0].totalTask, workerSet.size$-$preserved$)$\;
  result[jobSet[0]] $\gets$ $\{w_1, ..., w_c\}$\;
  \For{ i $\gets 1 \to min(m-c, n)$}{
	result[jobSet[i]] $\gets$ $\{w_{c+i}\}$
  }
  \Return{result}\;
  \caption{Priority-based policy}
  \label{algo:priority-based}
\end{algorithm}

\section{Proportion-based Policy}
This policy is unaware of job priorities; instead, the main concern of
this policy is the workload proportion of a job to all the others.


\begin{algorithm}
  \DontPrintSemicolon % Some LaTeX compilers require you to use
  \KwIn{
	workerSet=$\{w_1, w_2, \ldots, w_m\}$,
	jobSet=$\{j_1, j_2, \ldots, j_n\}$,
	preserving rate $r\in[0,1]$
  }
  \KwOut{The largest element in the set}
  result $\gets$ KeyValueMap(key $\to \{\}$ for all key $\in$ $jobSet$)\;
  jobSet $\gets$ $sortByPriority($jobSet$)$\;
  preserved $\gets$ $floor((1-r) * $workerSet.size$)$\;
  c $\gets$ $min($obSet[0].totalTask, workerSet.size$-$preserved$)$\;
  result[jobSet[0]] $\gets$ $\{w_1, ..., w_c\}$\;
  \For{ i $\gets 1 \to min(m-c, n)$}{
	result[jobSet[i]] $\gets$ $\{w_{c+i}\}$
  }
  \Return{result}\;
  \caption{Priority-based policy}
  \label{algo:naive-priority-based}
\end{algorithm}


\section{Deadline-based Policy}

\begin{algorithm}
  \DontPrintSemicolon % Some LaTeX compilers require you to use
  \KwIn{
	workerSet=$\{w_1, w_2, \ldots, w_m\}$,
	jobSet=$\{j_1, j_2, \ldots, j_n\}$,
	preserving rate $r\in[0,1]$
  }
  \KwOut{The largest element in the set}
  result $\gets$ KeyValueMap(key $\to \{\}$ for all key $\in$ $jobSet$)\;
  jobSet $\gets$ $sortByPriority($jobSet$)$\;
  preserved $\gets$ $floor((1-r) * $workerSet.size$)$\;
  c $\gets$ $min($obSet[0].totalTask, workerSet.size$-$preserved$)$\;
  result[jobSet[0]] $\gets$ $\{w_1, ..., w_c\}$\;
  \For{ i $\gets 1 \to min(m-c, n)$}{
	result[jobSet[i]] $\gets$ $\{w_{c+i}\}$
  }
  \Return{result}\;
  \caption{Priority-based policy}
  \label{algo:naive-priority-based}
\end{algorithm}
